using System.Collections.Generic;
using UnityEngine;

namespace CruiseLineInc.Ship
{
    /// <summary>
    /// Represents a complete cruise ship with multiple decks.
    /// Manages ship-level stats and resources.
    /// </summary>
    public class Ship : MonoBehaviour
    {
        [Header("Ship Configuration")]
        [SerializeField] private string _shipName = "Mistral";
        [SerializeField] private string _shipClass = "Coastal Cruiser";
        
        [Header("Capacity")]
        [SerializeField] private int _maxPassengers = 40;
        [SerializeField] private int _maxCrew = 10;
        [SerializeField] private int _totalTiles = 64;
        
        [Header("Resources")]
        [SerializeField] private float _waterCapacity = 150f;
        [SerializeField] private float _foodCapacity = 200f;
        [SerializeField] private float _wasteCapacity = 180f;
        
        [Header("Decks")]
        [SerializeField] private Transform _deckContainer;
        [SerializeField] private GameObject _deckPrefab;
        
        // Deck Management
        private List<Deck> _decks = new List<Deck>();
        private Dictionary<int, Deck> _decksByLevel = new Dictionary<int, Deck>();
        
        // Current Stats
        private int _currentPassengerCount;
        private int _currentCrewCount;
        private int _occupiedTiles;
        
        #region Properties
        
        public string ShipName => _shipName;
        public string ShipClass => _shipClass;
        public int MaxPassengers => _maxPassengers;
        public int MaxCrew => _maxCrew;
        public int TotalTiles => _totalTiles;
        public float WaterCapacity => _waterCapacity;
        public float FoodCapacity => _foodCapacity;
        public float WasteCapacity => _wasteCapacity;
        public List<Deck> Decks => _decks;
        public int CurrentPassengerCount => _currentPassengerCount;
        public int CurrentCrewCount => _currentCrewCount;
        public int OccupiedTiles => _occupiedTiles;
        public int AvailableTiles => _totalTiles - _occupiedTiles;
        
        #endregion
        
        #region Initialization
        
        private void Awake()
        {
            if (_deckContainer == null)
            {
                _deckContainer = transform;
            }
        }
        
        /// <summary>
        /// Initialize the ship with given configuration
        /// </summary>
        public void Initialize(string shipName, string shipClass, int maxPassengers, int maxCrew)
        {
            _shipName = shipName;
            _shipClass = shipClass;
            _maxPassengers = maxPassengers;
            _maxCrew = maxCrew;
            
            Debug.Log($"Ship '{_shipName}' ({_shipClass}) initialized: {_maxPassengers} pax, {_maxCrew} crew");
        }
        
        #endregion
        
        #region Deck Management
        
        /// <summary>
        /// Adds a deck to the ship (2D cross-section)
        /// </summary>
        public Deck AddDeck(int deckLevel, DeckType deckType, int width, float tileSize = 1f, Data.TileVisualData visualData = null)
        {
            // Check if deck already exists
            if (_decksByLevel.ContainsKey(deckLevel))
            {
                Debug.LogWarning($"Deck at level {deckLevel} already exists!");
                return _decksByLevel[deckLevel];
            }
            
            // Create deck GameObject
            GameObject deckObj = _deckPrefab != null 
                ? Instantiate(_deckPrefab, _deckContainer) 
                : new GameObject($"Deck_{deckLevel}_{deckType}");
            
            deckObj.transform.SetParent(_deckContainer);
            
            // Add or get Deck component
            Deck deck = deckObj.GetComponent<Deck>();
            if (deck == null)
            {
                deck = deckObj.AddComponent<Deck>();
            }
            
            // Initialize deck with 1D width and optional visual data
            deck.Initialize(deckLevel, deckType, width, tileSize, visualData);
            
            // Register deck
            _decks.Add(deck);
            _decksByLevel[deckLevel] = deck;
            
            // Sort decks by level
            _decks.Sort((a, b) => a.DeckLevel.CompareTo(b.DeckLevel));
            
            // Position decks adjacent to each other (stacked vertically)
            RepositionDecks(tileSize);
            
            Debug.Log($"Added Deck {deckLevel} ({deckType}) to {_shipName}: {width} tiles wide");
            
            return deck;
        }
        
        /// <summary>
        /// Repositions all decks so they're adjacent without gaps
        /// </summary>
        private void RepositionDecks(float tileSize)
        {
            float currentY = 0f;
            
            // Go through decks in sorted order (bottom to top)
            foreach (Deck deck in _decks)
            {
                deck.transform.localPosition = new Vector3(0, currentY, 0);
                currentY += tileSize; // Each deck is 1 tile tall
            }
        }
        
        /// <summary>
        /// Gets a deck by its level
        /// </summary>
        public Deck GetDeck(int deckLevel)
        {
            return _decksByLevel.ContainsKey(deckLevel) ? _decksByLevel[deckLevel] : null;
        }
        
        /// <summary>
        /// Gets all decks of a specific type
        /// </summary>
        public List<Deck> GetDecksByType(DeckType deckType)
        {
            return _decks.FindAll(d => d.DeckType == deckType);
        }
        
        /// <summary>
        /// Gets the top deck (highest level)
        /// </summary>
        public Deck GetTopDeck()
        {
            return _decks.Count > 0 ? _decks[_decks.Count - 1] : null;
        }
        
        /// <summary>
        /// Gets the bottom deck (lowest level)
        /// </summary>
        public Deck GetBottomDeck()
        {
            return _decks.Count > 0 ? _decks[0] : null;
        }
        
        #endregion
        
        #region Tile Statistics
        
        /// <summary>
        /// Updates occupied tile count
        /// </summary>
        public void UpdateOccupiedTiles()
        {
            _occupiedTiles = 0;
            foreach (Deck deck in _decks)
            {
                foreach (Tile tile in deck.Tiles)
                {
                    if (tile.IsOccupied)
                    {
                        _occupiedTiles++;
                    }
                }
            }
        }
        
        /// <summary>
        /// Gets total buildable tiles across all decks
        /// </summary>
        public int GetBuildableTileCount()
        {
            int count = 0;
            foreach (Deck deck in _decks)
            {
                count += deck.GetBuildableTiles().Count;
            }
            return count;
        }
        
        #endregion
        
        #region Agent Management
        
        /// <summary>
        /// Sets the current passenger count
        /// </summary>
        public void SetPassengerCount(int count)
        {
            _currentPassengerCount = Mathf.Clamp(count, 0, _maxPassengers);
        }
        
        /// <summary>
        /// Sets the current crew count
        /// </summary>
        public void SetCrewCount(int count)
        {
            _currentCrewCount = Mathf.Clamp(count, 0, _maxCrew);
        }
        
        /// <summary>
        /// Checks if the ship can accommodate more passengers
        /// </summary>
        public bool CanAddPassengers(int count)
        {
            return (_currentPassengerCount + count) <= _maxPassengers;
        }
        
        /// <summary>
        /// Checks if the ship can accommodate more crew
        /// </summary>
        public bool CanAddCrew(int count)
        {
            return (_currentCrewCount + count) <= _maxCrew;
        }
        
        #endregion
        
        #region Multi-Deck Room Support
        
        /// <summary>
        /// Checks if a room spanning multiple decks can be placed
        /// </summary>
        /// <param name="xPosition">Starting X position</param>
        /// <param name="width">Width of the room in tiles</param>
        /// <param name="startDeck">Starting deck level</param>
        /// <param name="deckHeight">Number of decks the room spans</param>
        /// <param name="requiredTileTypes">Optional: Required tile types for this room (null = any type allowed)</param>
        /// <returns>True if room can be placed</returns>
        public bool CanPlaceMultiDeckRoom(int xPosition, int width, int startDeck, int deckHeight, TileType[] requiredTileTypes = null)
        {
            for (int d = 0; d < deckHeight; d++)
            {
                int deckLevel = startDeck + d;
                Deck deck = GetDeck(deckLevel);
                
                if (deck == null)
                {
                    Debug.LogWarning($"Deck {deckLevel} doesn't exist!");
                    return false;
                }
                
                if (!deck.CanPlaceRoom(xPosition, width, requiredTileTypes))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        /// <summary>
        /// Places a room spanning multiple decks
        /// </summary>
        public void PlaceMultiDeckRoom(int xPosition, int width, int startDeck, int deckHeight, string roomId)
        {
            for (int d = 0; d < deckHeight; d++)
            {
                int deckLevel = startDeck + d;
                Deck deck = GetDeck(deckLevel);
                
                if (deck != null)
                {
                    // Mark tiles as part of multi-deck room, with startDeck as the root
                    deck.OccupyTiles(xPosition, width, roomId, isMultiDeck: true, rootDeckLevel: startDeck);
                }
            }
            
            Debug.Log($"Placed multi-deck room '{roomId}' at X:{xPosition} W:{width} " +
                     $"spanning decks {startDeck} to {startDeck + deckHeight - 1}");
        }
        
        /// <summary>
        /// Clears a multi-deck room
        /// </summary>
        public void ClearMultiDeckRoom(int xPosition, int width, int startDeck, int deckHeight)
        {
            for (int d = 0; d < deckHeight; d++)
            {
                int deckLevel = startDeck + d;
                Deck deck = GetDeck(deckLevel);
                deck?.ClearTiles(xPosition, width);
            }
        }
        
        #endregion
        
        #region Debug
        
        public void PrintShipInfo()
        {
            Debug.Log("=== SHIP INFO ===");
            Debug.Log($"Name: {_shipName}");
            Debug.Log($"Class: {_shipClass}");
            Debug.Log($"Decks: {_decks.Count}");
            Debug.Log($"Passengers: {_currentPassengerCount}/{_maxPassengers}");
            Debug.Log($"Crew: {_currentCrewCount}/{_maxCrew}");
            Debug.Log($"Tiles: {_occupiedTiles}/{_totalTiles} occupied");
            Debug.Log("================");
            
            foreach (Deck deck in _decks)
            {
                Debug.Log($"  - Deck {deck.DeckLevel} ({deck.DeckType}): {deck.Width} tiles wide");
            }
        }
        
        #endregion
    }
}
